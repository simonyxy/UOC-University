---
title:  Unity的内存管理
tag:  Unity学习
---
mono托管堆的东西~~
<!-- more -->
# unity 代码上的优化

## 1.减少GC（减少引用）
**Mono内存管理策略**
已用内存指的是mono实际需要使用的内存，堆内存指的是mono向操作系统申请的内存，两者的差值就是mono的空闲内存。

当mono需要分配内存时，会先查看空闲内存是否足够，如果足够的话，直接在空闲内存中分配，否则mono会进行一次GC以释放更多的空闲内存，如果GC之后仍然没有足够的空闲内存，则mono会向操作系统申请内存，并扩充堆内存。GC释放的内存只会留给mono使用，并不会交还给操作系统，也就意味着MONO的申请内存是*只增不减的*。所以我们需要尽量避免让mono去申请空间。

GC的主要作用在于从已用内存中找出那些不再需要使用的内存，并进行释放。GC虽然可以优化内存之外，但是调用一次GC会增加CPU的开销。 所以要恰当管理mono的托管堆，少手动调用GC，GC会在空间不足的时候调用，所以我们要控制堆空间的生成。尽量减少空间的消耗。减少GC还能优化CPU,太多调用GC只会。

*减少mono托管堆里的东西可以优化内存，减少调用GC可以优化CPU*
+ Mono的托管堆，管理
  调用GC的两种情况：1.手动调用 2.堆内存不足
  我们要减少调用也就是减少 在代码里面对堆内存的申请
-string . stringBuilder 和stringBuffer , ~多连接不要用string  ~用stringBuilder ~stringBuffer是考虑线程安全的情况下讨论
-少用foreach ，用for 。 foreach其实会涉及到迭代器IEnum（Iterator）的使用，而据传说每一次循环所产生的迭代器会带来24 Bytes的垃圾。那么循环10次就是240Bytes
-不要直接访问gameobject的tag属性。比如if (go.tag == “human”)最好换成if (go.CompareTag (“human”))。因为访问物体的tag属性会在堆上额外的分配空间。如果在循环中这么处理，留下的垃圾就可想而知了。
-对象池。 重复使用
-结构体替代类


**2.减少与Unity底层（C++）的交互**
这一部分主要是针对CPU以及代码性能优化，Unity是用C++写的， 开发写的脚本用C# ，交互会消耗性能。C#是由mono运行时托管的。而功能是底层引擎的C++实现的，“游戏脚本”中的功能实现都离不开对底层代码的调用。比如：
+ 只调用一次GetComponent方法，只获取一次Transform属性用变量保存.....
- 善于使用OnBecameVisible()和OnBecameVisible(),来控制物体的update()函数的执行以减少开销
- 使用内建的数组，比如用Vector3.zero而不是new Vector(0, 0, 0);
- 用ref ，值类型的参数都是复制到形参的，ref可以优化脚本性能

其实真的要去探究代码上优化的东西，还是有很多需要说的，但是主要指出方向怕自己忘记了，日后自己再研究补充吧！

Simonyxy