简单粗暴的帧同步方法。
每帧调用一个update方法向服务端发送自己的 位置，服务端返回位置的变化，然后客户端改变坦克的位置。（会有顿挫感，因为位置在漂移）
把同步频率放的很高的话，一秒能否解决这个问题24帧。？
不能

UDP 不可靠 无序（先发送后到达） 延迟 抖动（接受到两个包的时间不是稳定的，就算发送的时间间隔稳定）
TCP √	   √		延迟   抖动

解决延迟和抖动
抖动对移动同步会有很大的问题（特别像上面那样的方式）
抖动导致降频（A发了七帧，B收到的时候实际上只有三帧）
 
pos	p	p1
pos	
pos	pp	pp5  - 》 1~5  
pos
pos	pp	
pos	
pos	
pos	ppp
pos	p	pppppp
pos	p	pp

插值  -》 延时-》平滑
预测 1,1-3,3 1,1- 6.6  
缓存 -》 queue  - 》  frameUpdate（if(queue.Count < 5) queue.dequeu  ）
冗余


也就是发送到20几帧30几帧，客户端接收的频率也不高。所以光增加发送帧率是不行滴。（特别网络越卡越明显）

移动优化算法
（没法改变网络延迟 ，想办法呗）
①插值算法 （人为的 给一个更大的延迟，做移动）客户端不直接将实体拉到目的地，而是让实体以一定的速度移动到目的地
用误差换平滑（延迟会变大，因为我们做延迟了，但是会平滑一点，看上去一直在移动） 
两个点的时候，可以计算出速度和加速度，给一个非常平滑的移动。
ARPG类型里面会用到很多插值算法

2.预测算法
预测他将要移动的位置，一般是向前，因为本身就有延迟，预测他的移动轨迹，就会更加同步。
坏处：假如玩家 不是匀速或匀加速的移动，玩家突然停止。 玩家A->B  玩家B看到的 A ->C -> B 

3.缓存队列 （一定会用）
客户端收到信息后，不直接展示移动。先缓存起来，从另外一个地方去取。能保证取队列的时候是按一定时间去取，这样能做到
保证每次取移动协议的时候时间间隔是一定的
例子：处理缓存信息：当缓存信息大于5，直接忽略队列里的信息。 当缓存信息大于3，加速执行。 当缓存小于三，正常速度执行

解决不稳定
1.信息冗余

解决无序
1.给协议头部加上特定id


同步方法归类：
客户端还是服务端计算？状态同步还是帧同步？
很多游戏都混合的。比如战斗很复杂，客户端开发会低一些，那就可以客户端去做一些计算。或者服务端运算能力不行。
状态 -》状态（坐标）（客户端运算，客户端告诉服务端我的位置 ）
指令 （前进指令）-》 状态（状态）
指令（前进） - 服务端只做转发》指令 （前进）  【帧同步】

帧同步算法(快速的回合制)
帧同步分为很多轮（一轮就是一次画面更新）
每一轮包括 ，收集指令，转发消息，执行消息，回合结束  服务端收到回合结束，开启下一轮
锁帧同步重点在于“锁”，把实时游戏变为快
1.为了表现优化，一轮会包含很多帧，比如四轮一帧。每帧执行的逻辑都会做，像前面说的那些缓存队列都会执行，游戏看起来会流畅
2.为了表现优化。会有指令流水线。一遍执行，一边收集下一阵输入

如图：
收集 执行 结束
 30     29    29  
  
        收集 执行 结束
         31     30   30
	
	收集 执行 结束
 	 32     31    31  



如果有玩家慢了怎么办
1.严格帧同步
 所有人等他 ，这个所有人延迟都被影响 ， 不太好。局域网的情况比较合适
2.乐观帧同步
不等待，服务端无论如何都是按一定时间作为一轮，有人延迟就不管，让他延迟。延迟一般都是暂时的。
如果有延迟，后面让客户端做一个追帧。客户端队列里比较多或者时间跟帧差的比较多了，他就会追帧，加速执行帧。这个会差不多同步


帧同步存在的问题
锁帧 -》保证相同的序列和时间
浮点数-》 哥哥平台不同实现需要统一
随机数 -》使用相同的种子和随机算法