玩家移动首先是通过状态机
FixedUpdate对于操作不敏感，把timestep改为0.01

问题：
为啥我的连续跳跃不流畅？
FSM状态切换
首先我的每个状态切换时，当切换到新的状态中那一瞬间，他不会去从新的状态中读取转化信息看是否能转换为其他状态，这里可能会造成一些极限操作上的问题
比如我需要从一个平台跳到另外一个平台上，中间隔着一块会消失的木板，我需要玩家进行一次连续跳跃的操作，但是因为连续跳跃需要从  从Jump状态转移到Idle状态，再从Idle状态转移到Jump
那么在Jump转移到Idle的那一帧中，状态机首先进行的查找jump状态里面有没有可以转移到别的状态的条件，当状态机发现满足了jump转移到Idle状态的条件。那么他就会触发Jump状态的退出函数 和 Idle状态的进入函数，但是在传统状态机中，在这一帧，他没有去遍历Idle的转移条件也就是在这一帧，一定是进入的Idle状态。只有下一帧才会去判断是否能满足进入下一个Jump状态。
那么对于连续跳跃操作来说，玩家连续跳跃会需要两帧去完成，中间会丢失一帧的时间去进入Idle状态，虽然只有一瞬间的操作，对于大部分情况下，这样的逻辑处理是没有太大的影响的，但是如果刚好在落地的瞬间进入丢失的一帧，也会产生不流畅的感觉。所以我当时是修改在帧与帧转换之间，对新状态的转移条件也进行一次判断
这也就意味着，在这一帧，我们从Jump状态转移到了Idel状态，然后需要进入Idle状态，对于Idle状态的转化条件也需要判断查看是否能进入Jump状态。

从两个方面想了四个解决方法，首先是对idle转移jump进行特殊的处理，专门在进入idle状态的函数中特殊判断jump；第二是直接修改状态机底层结构，让每次进入一次新状态就要遍历一次新状态的转移条件而不是就直接调用进入状态的方法，如果有可以转移的条件就让这个状态成为一个中间状态。

第一个方面是让状态机进行转化，有两种方法：
但是两种解决方法都会有一些负面效果
第一种方法：进入Idle状态后改变
优点：
对FSM其他部分的性能几乎无影响的情况下解决问题
缺点：
1.直接在Jump转移到Idle状态的过程中进行特殊处理，在进入Idle状态的函数中进行Jump的判断(在这个函数是因为进入状态那一帧会调用这个IDle状态进入函数)，但这样的方法本身非常不可取。因为本质上已经脱离了FSM的设计概念，FSM设计的初衷本就应该是“细节依赖抽象，抽象不依赖细节，基于抽象编程，让框架先跑起来”。也就是对状态内部的运行函数越单纯越好，不应该跟其他状态有一个耦合，或者有对其他状态的特殊处理。FSM条件的转换都应该是放在中间管理条件跳转层中。不能放在某一个状态进行中进行条件判断。所以这个方法最不可取
第二种方法：直接更改状态机底层结构，状态转化后对新状态也进行一次转换状态判断
优点：
在不影响FSM设计理念的基础上，完成设计
对于所有转移状态的极限边界情况都能得到改善（如连续跳跃，连续使用技能，跳跃后使用技能等一帧中连续切换多个状态）
缺点：
第一，这样修改会对状态机的性能有一定影响，每一次转换条件都需要判断两个甚至多个状态的条件变化
第二，如果只考虑连续跳跃这样的情况，这样修改状态机是成立的。但是如果对于比较复杂的状态机，可能会有死循环的情况出现。这样的情况如果在FSM设计转化条件不耦合，情况不复杂的情况下是可以考虑的，但是如果出错调试起来会非常麻烦

另一个方面是直接从Jump状态上考虑：
方法：直接不让jump状态退出，在临界状态让jump连续
玩家落地的瞬间，直接在条件中判断是否进行了跳跃的按下。这种方法我觉得是目前最适合我项目的方法，虽然比较“笨”的增加了特殊情况的代码量，但是并没有对其他状态有一个耦合。且对性能有很大的好处，而且执行时间在逻辑上是最正确的，直接放弃了状态的转移，而是继续让玩家处于跳跃状态。我认为在基本操作中跳跃本身的临界特殊判断也是必须的。当然如果对状态机的转移条件设计的比较简单和清楚的情况下，第二种方法也是可取的。

不得不说，对于简单操作游戏的玩家控制器，FSM也不一定好用，继续加油！

我发现即使我修改了上面的逻辑，但是我连续跳跃还是会有问题，所以我就去找真正的原因
对于跳跃按钮，他是不是“死”的太慢了？
对于落地检测，是不是检测的太慢了？

